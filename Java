Functional interfaces:
 An interface that contains only one abstract method. They can contain other default methods but only one abstract method is allowed. @FunctionalInterface is the optional annotation for compiler to know if the interface is functional.
 Comparable
 Runnable
 Callable
 java.util.function (https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html) important ones
   Note : generic parameters (for example, the T in Consumer<T>) can be bound only to reference types. So use above functional interface when you want to pass reference object and use 
  the primitive typed functional interface like IntPredicate when using primitive values. Else, there will be a performance impact when boxing and unboxing.Boxed values are a wrapper around primitive types and are stored on the heap. 
  Therefore, boxed values use more memory and require additional memory lookups to fetch the wrapped primitive value. 
   Predicate<T> 	T -> boolean 	
     IntPredicate, LongPredicate,DoublePredicate 
     
   Consumer<T> 	T -> void 	
     IntConsumer, LongConsumer,DoubleConsumer 
     
   Function<T, R> 	T -> R 
    IntFunction<R>,
    IntToDoubleFunction,
    IntToLongFunction,
    LongFunction<R>,
    LongToDoubleFunction,
    LongToIntFunction,
    DoubleFunction<R>,
    DoubleToIntFunction,
    DoubleToLongFunction,
    ToIntFunction<T>,
    ToDoubleFunction<T>,
    ToLongFunction<T> 
    
  Supplier<T> 	() -> T 	
     BooleanSupplier, IntSupplier,LongSupplier, DoubleSupplier 
     
 UnaryOperator<T> 	T -> T 	
   IntUnaryOperator,
   LongUnaryOperator,
   DoubleUnaryOperator 
   
 BinaryOperator<T> 	(T, T) -> T 	
   IntBinaryOperator,
   LongBinaryOperator,
   DoubleBinaryOperator 
   
 BiPredicate<T, U> 	(T, U) -> boolean
 
 
 BiConsumer<T, U> 	(T, U) -> void 	
  ObjIntConsumer<T>,
  ObjLongConsumer<T>,
  ObjDoubleConsumer<T> 
 
 iFunction<T, U, R> 	(T, U) -> R 	
  ToIntBiFunction<T, U>,
  ToLongBiFunction<T, U>,
  ToDoubleBiFunction<T, U> 

  
  
  
